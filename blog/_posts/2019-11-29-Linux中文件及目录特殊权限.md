***在Linux中，每个文件或者目录都有自己的权限，有些文件所有人都可以看，但是不能更改；或者部分人可以查看或者更改，就像在公司中的每个文件对于职位不同的人权限是不同的，而这些权限作用在目录上和作用在文件上有什么不同呢？或者某些文件或者目录的特殊权限又是什么呢？，下面是我总结出的权限对于文件和目录的作用，及特殊权限***

----------
r：Read 读       w：Write  写    x：Excute 执行

**对于文件来说**，这三个的组合会出现什么结果，不管文件还是目录，当他们的权限是rwx的时候就是读写更改都行的，这没什么说的。
当只有r的时候，文件是可读的，也就是说可以通过cat得到其中的内容
当只有w的时候，文件是可写的，可通过文本编辑器修改其内容
当只有x的时候，没有什么作用（内容都读不到，怎么执行呢）
当rw的时候，可以读写
当rx的时候，可读可执行
当wx的时候，跟一个w效果是一样的

**对于目录来说**，x有什么用呢，又不能像程序一样去执行，在这里x就是进入目录
当只有r的时候，可以短列出目录下的内容
当只有w的时候，什么也做不了（都进入不了目录，如何写呢）
当只有x的时候，进入目录
当rw的时候，跟一个r是一样的
当rx的时候，可进入目录并长列出目录下内容
当wx的时候，可进入目录并且可以创建及删除文件或目录

**权限的数字表达方式**：r：4    w：2     x：1  -：0

rwx就是7权限了

正常来说，一个文件或目录的权限分为三部分
rwx  r-x  r--  前三个是对于文件或目录所属人来说的（owner）
                    中间三个是所属组（group）
                   最后一个是对于其他人来说的（other）
                   
但有时候我们需要一些特殊权限，比如，我需要以文件所属人的身份来执行这个文件，或者我需要一些人对一个rwxr-x---权限的文件有读写权限，这时候怎么办呢，把这些人作为文件的owner很显然是不行的，让这些人加入组好像也不行，这样仅有rwx是不行的，就涉及到特殊权限了。特殊权限主要介绍三个suid，sgid，acl

**suid权限**

suid的作用就是当对于一个**可执行的二进制文件**作用了suid之后，任何人在执行文件时，临拥有其所属人的权限。方法就是chmod u+s FILENAME

```
[root@localhost ~]# ls -l /app/eg
-rwxr--r--. 1 root root 67 7月  21 19:58 /app/eg
[root@localhost ~]# chmod u+s /app/eg 
[root@localhost ~]# ls -l /app/eg
-rwsr--r--. 1 root root 67 7月  21 19:58 /app/eg


```

 可以看到作用了suid权限后，在ower权限位多了一个s，原来的x没了，但是通过执行文件能知道x的作用并没有消失，所以只是隐藏了，这时候如果切换用户再去执行文件就是以文件所属人的身份去执行了。

**sgid权限**

sgid的第一个作用跟suid是一样的，第二个作用则是当对于一个目录作用了sgid权限后，任何人在该目录下所创建的文件的所属组，均与该目录的所属组相同。使用方法跟suid有点类似 chmod g+s FILENAME

**ACL权限**

Access Control List（访问控制列表）
这个权限有什么用呢？这就可以用来解决我上面说的问题了，这就像是公司里有一个文件，公司里的员工都可以读写这个文件，其他人无任何权限，而公司里突然来了一个临时员工，他只有读和执行权限，并没有写的权限，这时候权限的分配就要用到ACL权限了
在centos7中 默认支持acl，而centos6及之前，操作系统安装时所创建的文件系统默认支持acl，而操作安装之后使用mkfs格式化的文件系统默认未开启acl，需要手工开启，方法如下：

```
	[root@localhost ~]# tune2fs -o acl /dev/sda5
	[root@localhost ~]# mount -o acl /dev/sda5 /app
```
要判断一个文件或目录是否加了ACL权限，就看权限位最后是否有一个+，如果有，则就有ACL权限，这时查看权限就要用getfacl FILENAME查询了。设置ACL的方法则是setfacl  FILENAME ，在这里setfacl有几个选项
-b 去掉所有acl权限即清空所有acl属性
         -m  设置ACL权限，后面跟用户或目录  
         -x 一条一条删除  
          -X批量删除acl权限
          -M 批量设置acl
         -R 递归
acl权限删除之后是可以恢复的，恢复方法如下：

```
[root@localhost app]# getfacl  * >> /root/acl.txt 复制ACL权限到acl.txt
[root@localhost app]# setfacl -Rb /app 清除acl权限
[root@localhost app]# setfacl --restore /root/acl.txt 恢复ACL权限
```
可以看出，acl权限可以实现用户或用户组对一个文件或文件夹灵活的权限管理。
另外再增加两条特殊权限***sticky***，***chattr***

  **sticky**

在对一个目录作用了sticky权限后，该目录下的文件仅其文件所属人，目录所属人和root能删除，其他人无权删除。
给目录增加sticky权限方法如下
```
[root@localhost app]# chmod o+t /app/
[root@localhost app]# su - liubei
[liubei@localhost app]$ rm -f answer
rm: cannot remove `answer': Permission denied

```
而去掉这个权限则跟增加权限一样，只不过是chmod o-t。

 ***chattr***

 上面的sticky权限作用给目录之后仅仅是不能删除文件，但是别人是可以更改的，这就要用到chattr权限了，相应的，chattr权限就是这个作用l，防止别人更改文件，用法如下
 

```
[root@localhost app]# ls
answer  head  house  passwd
[root@localhost ~]# chattr +a /app/
[root@localhost app]# rm -f answer 
rm: cannot remove `answer': Operation not permitted
[root@localhost app]# echo aaaa > answer
[root@localhost app]# cat answer 
aaaa

```
这个选项 即chattr +a作用到目录之后，目录中的文件则不能删除，不能覆盖，但是可以追加
而chattr +i 作用到目录之后，除了能查看，其他什么都做不了

```
[root@localhost app]# chattr +i /app
[root@localhost app]# rm -f answer 
rm: cannot remove `answer': Permission denied
[root@localhost app]# touch aa
touch: cannot touch `aa': Permission denied
```
这两个特殊权限的取消方式也很简单，把+变成-执行一遍就能把这两个权限取消掉了

希望能帮助你的理解，助你学习，也希望你能想出更易于理解的思路。
